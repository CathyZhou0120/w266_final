Query: list the first 100 Fibonacci Numbers

************************** NEXT RESULT **************************************
#!/usr/bin/env python
# encoding: utf-8
from .fetcher import *
from .territory import *

class KKBOXNewHitsPlaylistFetcher(Fetcher):
    '''
    List all new hits playlists and fetch tracks for specific new hit playlist.

    See 'https://docs-en.kkbox.codes/v1.1/reference#new-hits-playlists'.
    '''
    @assert_access_token
    def fetch_all_new_hits_playlists(self, terr=KKBOXTerritory.TAIWAN):
        '''
        Fetches all new hits playlists.

        :param terr: the current territory.
        :return: API response.
        :rtype: dict

        See 'https://docs-en.kkbox.codes/v1.1/reference#newhitsplaylists'
        '''
        url = 'https://api.kkbox.com/v1.1/new-hits-playlists'
        url += '?' + url_parse.urlencode({'territory': terr})
        return self.http._post_data(url, None, self.http._headers_with_access_token())

    @assert_access_token
    def fetch_new_hits_playlist(self, playlist_id, terr=KKBOXTerritory.TAIWAN):
        '''
        Fetches new hits playlist by given ID.

        :param playlist_id: the playlist ID.
        :type playlist_id: str
        :param terr: the current territory.
        :return: API response.
        :rtype: dict

        See 'https://docs-en.kkbox.codes/v1.1/reference#newhitsplaylists-playlist_id'
        '''
        url = 'https://api.kkbox.com/v1.1/new-hits-playlists/%s' % playlist_id
        url += '?' + url_parse.urlencode({'territory': terr})
        return self.http._post_data(url, None, self.http._headers_with_access_token())

    @assert_access_token
    def fetch_new_hits_playlist_tracks(self, playlist_id, terr= KKBOXTerritory.TAIWAN):
        '''
        Fetches new hits playlist by given ID.

        :param playlist_id: the playlist ID.
        :type playlist_id: str
        :param terr: the current territory.
        :return: API response.
        :rtype: dict

        See 'https://docs-en.kkbox.codes/v1.1/reference#newhitsplaylists-playlist_id-tracks'
        '''
        url = 'https://api.kkbox.com/v1.1/new-hits-playlists/%s/tracks' % playlist_id
        url += '?' + url_parse.urlencode({'territory': terr})
        return self.http._post_data(url, None, self.http._headers_with_access_token())

Query: list the first 100 Fibonacci Numbers

************************** NEXT RESULT **************************************
from api.decorators import api_view, request_data_defaultdc
from api.permissions import IsSuperAdmin
from api.node.base.api_views import NodeView

__all__ = ('node_list', 'node_manage')


@api_view(('GET',))
@request_data_defaultdc(permissions=(IsSuperAdmin,))
def node_list(request, data=None):
    """
    List (:http:get:`GET </node>`) all nodes.

    .. http:get:: /node

        :DC-bound?:
            * |dc-no|
        :Permissions:
            * |SuperAdmin|
        :Asynchronous?:
            * |async-no|
        :arg data.full: Return list of objects with some compute node details (default: false)
        :type data.full: boolean
        :arg data.extended: Return list of objects with extended compute node details (default: false)
        :type data.extended: boolean
        :arg data.order_by: :ref:`Available fields for sorting <order_by>`: ``hostname`` (default: ``hostname``)
        :type data.order_by: string
        :status 200: SUCCESS
        :status 403: Forbidden
    """
    return NodeView(request, data=data).get(None, many=True)


@api_view(('GET',))
@request_data_defaultdc(permissions=(IsSuperAdmin,))
def node_manage(request, hostname, data=None):
    """
    Show (:http:get:`GET </node/(hostname)>`) compute node details.

    .. http:get:: /node/(hostname)

        :DC-bound?:
            * |dc-no|
        :Permissions:
            * |SuperAdmin|
        :Asynchronous?:
            * |async-no|
        :arg data.extended: Display extended compute node details (default: false)
        :type data.extended: boolean
        :status 200: SUCCESS
        :status 403: Forbidden
        :status 404: Node not found
    """
    return NodeView(request, data=data).response(hostname)

Query: list the first 100 Fibonacci Numbers

************************** NEXT RESULT **************************************
import re

from errbot import BotPlugin, re_botcmd


class The_rules(BotPlugin):
    """
    List the bot rules
    """

    @re_botcmd(pattern=r'the\s+rules',
               re_cmd_name_help='the rules',
               flags=re.IGNORECASE,
               template='the_rules.jinja2')
    def the_rules(self, msg, args):
        """
        Show the bot rules.
        """
        return {'rules': True}

Query: list the first 100 Fibonacci Numbers

************************** NEXT RESULT **************************************
# coding=utf-8
# Copyright 2014 Pants project contributors (see CONTRIBUTORS.md).
# Licensed under the Apache License, Version 2.0 (see LICENSE).

from __future__ import (absolute_import, division, generators, nested_scopes, print_function,
                        unicode_literals, with_statement)

import json
from collections import defaultdict

from pants.base.specs import DescendantAddresses
from pants.task.console_task import ConsoleTask


class ReverseDepmap(ConsoleTask):
  """List all targets that depend on any of the input targets."""

  @classmethod
  def register_options(cls, register):
    super(ReverseDepmap, cls).register_options(register)
    register('--transitive', type=bool,
             help='List transitive dependees.')
    register('--closed', type=bool,
             help='Include the input targets in the output along with the dependees.')
    # TODO: consider refactoring out common output format methods into MultiFormatConsoleTask.
    register('--output-format', default='text', choices=['text', 'json'],
             help='Output format of results.')

  def __init__(self, *args, **kwargs):
    super(ReverseDepmap, self).__init__(*args, **kwargs)

    self._transitive = self.get_options().transitive
    self._closed = self.get_options().closed

  def console_output(self, _):
    dependees_by_target = defaultdict(set)
    for address in self.context.build_graph.inject_specs_closure([DescendantAddresses('')]):
      target = self.context.build_graph.get_target(address)
      # TODO(John Sirois): tighten up the notion of targets written down in a BUILD by a
      # user vs. targets created by pants at runtime.
      concrete_target = self.get_concrete_target(target)
      for dependency in concrete_target.dependencies:
        dependency = self.get_concrete_target(dependency)
        dependees_by_target[dependency].add(concrete_target)

    roots = set(self.context.target_roots)
    if self.get_options().output_format == 'json':
      deps = defaultdict(list)
      for root in roots:
        if self._closed:
          deps[root.address.spec].append(root.address.spec)
        for dependent in self.get_dependents(dependees_by_target, [root]):
          deps[root.address.spec].append(dependent.address.spec)
      for address in deps.keys():
        deps[address].sort()
      yield json.dumps(deps, indent=4, separators=(',', ': '), sort_keys=True)
    else:
      if self._closed:
        for root in roots:
          yield root.address.spec

      for dependent in self.get_dependents(dependees_by_target, roots):
        yield dependent.address.spec

  def get_dependents(self, dependees_by_target, roots):
    check = set(roots)
    known_dependents = set()
    while True:
      dependents = set(known_dependents)
      for target in check:
        dependents.update(dependees_by_target[target])
      check = dependents - known_dependents
      if not check or not self._transitive:
        return dependents - set(roots)
      known_dependents = dependents

  def get_concrete_target(self, target):
    return target.concrete_derived_from

Query: list the first 100 Fibonacci Numbers

************************** NEXT RESULT **************************************
# coding=utf-8
from __future__ import print_function, unicode_literals

import glob
import os

from bgmi.config import SAVE_PATH, DOWNLOAD_DELEGATE
from bgmi.lib.models import STATUS_DOWNLOADING, STATUS_NOT_DOWNLOAD, Download
from bgmi.downloader.aria2_rpc import Aria2DownloadRPC
from bgmi.downloader.transmission_rpc import TransmissionRPC
from bgmi.downloader.xunlei import XunleiLixianDownload
from bgmi.utils import print_error


DOWNLOAD_DELEGATE_DICT = {
    'xunlei': XunleiLixianDownload,
    'aria2-rpc': Aria2DownloadRPC,
    'transmission-rpc': TransmissionRPC,
}


def get_download_class(download_obj=None, save_path='', overwrite=True, instance=True):
    if DOWNLOAD_DELEGATE not in DOWNLOAD_DELEGATE_DICT:
        print_error('unexpected delegate {0}'.format(DOWNLOAD_DELEGATE))

    delegate = DOWNLOAD_DELEGATE_DICT.get(DOWNLOAD_DELEGATE)

    if instance:
        delegate = delegate(download_obj=download_obj, overwrite=overwrite, save_path=save_path)

    return delegate


def download_prepare(data):
    """
    list[dict]
    dict[
    name:str, keyword you use when search
    title:str, title of episode
    episode:int, episode of bangumi
    download:str, link to download
    ]
    :param data:
    :return:
    """
    queue = save_to_bangumi_download_queue(data)
    for download in queue:
        # print(download)
        save_path = os.path.join(os.path.join(SAVE_PATH, download.name), str(download.episode))
        if not glob.glob(save_path):
            os.makedirs(save_path)
        # mark as downloading
        download.status = STATUS_DOWNLOADING
        download.save()
        try:
            # start download
            download_class = get_download_class(download_obj=download, save_path=save_path)
            download_class.download()
            download_class.check_download(download.name)

            # mark as downloaded
            download.downloaded()
        except Exception as e:
            if os.getenv('DEBUG'):  # pragma: no cover
                import traceback
                traceback.print_exc()
                raise e

            print_error('Error: {0}'.format(e), exit_=False)
            download.status = STATUS_NOT_DOWNLOAD
            download.save()


def save_to_bangumi_download_queue(data):
    """
    list[dict]
    dict:{
    name;str, keyword you use when search
    title:str, title of episode
    episode:int, episode of bangumi
    download:str, link to download
    }
    :param data:
    :return:
    """
    queue = []
    for i in data:
        download, _ = Download.get_or_create(title=i['title'], download=i['download'],
                                             name=i['name'], episode=i['episode'],
                                             status=STATUS_NOT_DOWNLOAD)

        queue.append(download)

    return queue

Query: list the first 100 Fibonacci Numbers

************************** NEXT RESULT **************************************
# Rekall Memory Forensics
# Copyright (C) 2007-2011 Volatile Systems
# Copyright 2013 Google Inc. All Rights Reserved.
#
# Additional Authors:
# Michael Cohen <scudette@users.sourceforge.net>
# Mike Auty <mike.auty@gmail.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

# pylint: disable=protected-access

from future import standard_library
standard_library.install_aliases()
from rekall import testlib
from rekall_lib import utils

from rekall.plugins.common import memmap
from rekall.plugins.windows import common


class WinPsList(common.WinProcessFilter):
    """List processes for windows."""

    __name = "pslist"

    eprocess = None

    table_header = [
        dict(type="_EPROCESS", name="_EPROCESS"),
        dict(name="ppid", width=6, align="r"),
        dict(name="thread_count", width=6, align="r"),
        dict(name="handle_count", width=8, align="r"),
        dict(name="session_id", width=6, align="r"),
        dict(name="wow64", width=6),
        dict(name="process_create_time", width=24),
        dict(name="process_exit_time", width=24)
    ]

    def column_types(self):
        result = self._row(self.session.profile._EPROCESS())
        result["handle_count"] = result["ppid"]
        result["session_id"] = result["ppid"]

        return result

    def _row(self, task):
        return dict(_EPROCESS=task,
                    ppid=task.InheritedFromUniqueProcessId,
                    thread_count=task.ActiveThreads,
                    handle_count=task.ObjectTable.m("HandleCount"),
                    session_id=task.SessionId,
                    wow64=task.IsWow64,
                    process_create_time=task.CreateTime,
                    process_exit_time=task.ExitTime)

    def collect(self):
        for task in self.filter_processes():
            yield self._row(task)


class WinDllList(common.WinProcessFilter):
    """Prints a list of dll modules mapped into each process."""

    __name = "dlllist"

    table_header = [
        dict(name="divider", type="Divider"),
        dict(name="_EPROCESS", hidden=True),
        dict(name="base", style="address"),
        dict(name="size", style="address"),
        dict(name="reason", width=30),
        dict(name="dll_path"),
    ]

    def collect(self):
        for task in self.filter_processes():
            pid = task.UniqueProcessId

            divider = "{0} pid: {1:6}\n".format(task.ImageFileName, pid)

            if task.Peb:
                divider += u"Command line : {0}\n".format(
                    task.Peb.ProcessParameters.CommandLine)

                divider += u"{0}\n\n".format(task.Peb.CSDVersion)
                yield dict(divider=divider)

                for m in task.get_load_modules():
                    yield dict(base=m.DllBase,
                               size=m.SizeOfImage,
                               reason=m.LoadReason,
                               dll_path=m.FullDllName,
                               _EPROCESS=task)
            else:
                yield dict(divider="Unable to read PEB for task.\n")


class WinMemMap(memmap.MemmapMixIn, common.WinProcessFilter):
    """Calculates the memory regions mapped by a process."""
    __name = "memmap"

    def _get_highest_user_address(self):
        return self.profile.get_constant_object(
            "MmHighestUserAddress", "Pointer").v()


class Threads(common.WinProcessFilter):
    """Enumerate threads."""
    name = "threads"

    table_header = [
        dict(name="_ETHREAD", style="address"),
        dict(name="pid", align="r", width=6),
        dict(name="tid", align="r", width=6),
        dict(name="start", style="address"),
        dict(name="start_symbol", width=30),
        dict(name="Process", width=16),
        dict(name="win32_start", style="address"),
        dict(name="win32_start_symb")
    ]

    def collect(self):
        cc = self.session.plugins.cc()
        with cc:
            for task in self.filter_processes():
                # Resolve names in the process context.
                cc.SwitchProcessContext(process=task)

                for thread in task.ThreadListHead.list_of_type(
                        "_ETHREAD", "ThreadListEntry"):

                    yield dict(_ETHREAD=thread,
                               pid=thread.Cid.UniqueProcess,
                               tid=thread.Cid.UniqueThread,
                               start=thread.StartAddress,
                               start_symbol=utils.FormattedAddress(
                                   self.session.address_resolver,
                                   thread.StartAddress),
                               Process=task.ImageFileName,
                               win32_start=thread.Win32StartAddress,
                               win32_start_symb=utils.FormattedAddress(
                                   self.session.address_resolver,
                                   thread.Win32StartAddress,
                                   ))


class WinMemDump(memmap.MemDumpMixin, common.WinProcessFilter):
    """Dump windows processes."""


class TestWinMemDump(testlib.HashChecker):
    """Test the pslist module."""

    PARAMETERS = dict(
        commandline="memdump %(pids)s --dump_dir %(tempdir)s",
        pid=2624)


class TestMemmap(testlib.SimpleTestCase):
    """Test the pslist module."""

    PARAMETERS = dict(
        commandline="memmap %(pids)s",
        pid=2624)


class TestMemmapCoalesce(testlib.SimpleTestCase):
    """Make sure that memmaps are coalesced properly."""

    PARAMETERS = dict(commandline="memmap %(pids)s --coalesce",
                      pid=2624)

Query: list the first 100 Fibonacci Numbers

************************** NEXT RESULT **************************************
# Copyright 2014
# Cisco, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not
# use this file except in compliance with the License. You may obtain a copy
# of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from cloudpulseclient import exceptions
from cloudpulseclient.openstack.common import cliutils as utils


def _print_list_field(field):
    return lambda obj: ', '.join(getattr(obj, field))


@utils.arg('--failed',
           dest='failed',
           action="store_true",
           default=False,
           help='Display only test results that have failed.')
@utils.arg('--period',
           metavar='<period>',
           help='List tests results that have been run in the last x minutes.')
def do_result(cs, args):
    """List all the test results"""
    search_opts = {
        'failed': args.failed,
        'period': args.period,
    }
    healtchecks = cs.healthcheck.list(search_opts=search_opts)
    columns = ('uuid', 'id', 'name', 'testtype', 'state')
    utils.print_list(healtchecks, columns,
                     {'versions': _print_list_field('versions')},
                     sortby_index=1)


@utils.arg('--name',
           metavar='<name>',
           help='Name of the test to run')
@utils.arg('--all-tests',
           metavar='<all_tests>',
           action='store_const',
           const='all_tests',
           help="Run all tests")
@utils.arg('--all-endpoint-tests',
           metavar='<all_endpoint_tests>',
           action='store_const',
           const='all_endpoint_tests',
           help="Run all endpoint tests")
@utils.arg('--all-operator-tests',
           metavar='<all_operator_tests>',
           action='store_const',
           const='all_operator_tests',
           help="Run all operator tests")
def do_run(cs, args):
    """Run a new manual test"""
    if not any([args.name, args.all_operator_tests,
                args.all_tests, args.all_endpoint_tests]):
        raise exceptions.CommandError(
            ("Usage: cloudpulse --name <testname>."
             "See 'cloudpulse help run' for details"))
    opts = {}
    opts['name'] = args.name or args.all_operator_tests or \
        args.all_tests or args.all_endpoint_tests
    healtcheck = cs.healthcheck.create(**opts)
    utils.print_dict(healtcheck._info)


@utils.arg('cpulse',
           metavar='<cpulse>',
           nargs='+',
           help='Id of the test result to show.')
def do_show(cs, args):
    """Show the detailed result of a test"""
    for id in args.cpulse:
        healthcheck = cs.healthcheck.get(id)
        utils.print_dict(healthcheck._info)


def do_test_list(cs, args):
    """Show a list of scenarios and tests in each scenario"""
    healthcheck = cs.healthcheck.get_test_list()
    utils.print_dict(
        healthcheck[0]._info, dict_property="Scenarios", dict_value="Tests")


@utils.arg('cpulse',
           metavar='<cpulse>',
           nargs='+',
           help='Id of the test result to delete.')
def do_delete(cs, args):
    """Delete the test result"""
    for id in args.cpulse:
        try:
            cs.healthcheck.delete(id)
        except Exception as e:
            print("Delete for cpulse %(cpulse)s failed: %(e)s" %
                  {'cpulse': id, 'e': e})

Query: list the first 100 Fibonacci Numbers

************************** NEXT RESULT **************************************
import click

from . import utils, views
from . import parsers as p
from .crontab import Crontab

try:
    from StringIO import StringIO
except ImportError:
    from io import StringIO

@click.group()
def crony():
    pass

@crony.command()
@click.option('--limit', default=0,
                help="Number of crons to display, displays all by default")
@click.argument('host', default='localhost', 
                        callback=p.parse_hostname_callback, 
                        required=False)
def ls(limit, host):
    """List cron jobs on a remote or local system"""
    ct = Crontab(**host)
    cps = ct.list()
    jobs = p.parse_file(cronfd=cps.stdout, num_lines=limit)

    if not jobs:
        return
    
    # create the table and display it
    click.echo(views.horizontal_table(jobs))

@crony.command()
@click.option('--ids', default="0", callback=p.parse_range_callback,
                      help='IDs of jobs to be deleted.')
@click.argument('dst_host', default='localhost', 
                        callback=p.parse_hostname_callback, 
                        required=False)
def rm(ids, dst_host):
    """Delete cron jobs from a remote or local system"""
    confirm_msg = "Delete all jobs at: %s? (yes/no)" % (dst_host['hostname'],)

    # delete entire crontab
    if 0 in ids and (click.prompt(confirm_msg) == 'yes'):
        dst_ct = Crontab(**dst_host)
        dst_ps = dst_ct.remove()
        for out in dst_ps.stdout:
            click.echo(out)
        click.echo("Crontab deleted")
    else:
        if not click.prompt("Delete selected jobs? (yes/no)") == "yes":
            return # exit if not confirmed

        # delete selected jobs
        click.echo("Fetching remote jobs")
        dst_ct = Crontab(**dst_host)
        dst_ps = dst_ct.list()
        dst_jobs = p.parse_file(cronfd=dst_ps.stdout)
        rm_jobs = dst_jobs.in_ids(ids)
        job_str = StringIO()

        for rm_job in rm_jobs:
            dst_jobs.remove(rm_job)

        utils.write_jobs(dst_jobs, job_str)
        rmt_ct = Crontab(**dst_host)

        # if there was only one job, delete the crontab
        click.echo("Applying changes")
        if len(dst_jobs):
            rmt_ps = rmt_ct.install(job_str.getvalue())
        else:
            rmt_ps = rmt_ct.remove()

        for out in rmt_ps.stdout:
            click.echo(out)

        click.echo("Selected jobs deleted")

@crony.command()
@click.option('--ids', callback=p.parse_range_callback,
                help="IDs of crons to be deleted.")
@click.argument('src_host', nargs=1, callback=p.parse_hostname_callback)
@click.argument('dst_host', nargs=1, callback=p.parse_hostname_callback)
def cp(ids, src_host, dst_host):
    """Copy cron jobs across servers"""
    src_ct = Crontab(**src_host)
    src_ps = src_ct.list()
    src_jobs = p.parse_file(cronfd=src_ps.stdout).in_ids(ids)
    job_str = StringIO()
    utils.write_jobs(src_jobs, job_str)

    dst_ct = Crontab(**dst_host)
    rmt_pd = dst_ct.append(job_str.getvalue())
    for out in rmt_pd.stdout:
        click.echo(out)

    click.echo("Done, copied: " + str(len(ids)))

if __name__ == '__main__':
    crony()


Query: list the first 100 Fibonacci Numbers

************************** NEXT RESULT **************************************
from hwt.code import And, Or
from hwt.hdl.typeShortcuts import hBit
from hwt.pyUtils.arrayQuery import where


def _getRd(intf):
    try:
        return intf.rd
    except AttributeError:
        pass
    return intf.ready


def _getVld(intf):
    try:
        return intf.vld
    except AttributeError:
        pass
    return intf.valid


def _exStreamMemberAck(m):
    c, n = m
    return c & n.ack()


class ExclusiveStreamGroups(list):
    """
    list of tuples (cond, StreamNode instance)
    Only one stream from this group can be activated at the time
    """

    def __hash__(self):
        return id(self)

    def sync(self, enSig=None):
        """
        Create synchronization logic between streams
        (generate valid/ready synchronization logic for interfaces)

        :param enSig: optional signal to enable this group of nodes
        :return: list of assignements which are responsible for synchronization
            of streams
        """
        expression = []
        for cond, node in self:
            if enSig is not None:
                cond = cond & enSig
            expression.extend(node.sync(cond))
        return expression

    def ack(self):
        """
        :return: expression which's value is high when transaction can be made
            over at least on child streaming node
        """
        return Or(*map(_exStreamMemberAck, self))


class StreamNode():
    """
    Group of stream master and slave interfaces to synchronize them to each other

    :ivar masters: interfaces which are inputs into this node
    :ivar slaves: interfaces which are outputs of this node
    :ivar extraConds: dict interface : extraConditionSignal
        where extra conditions will be added to expression for channel enable
        for master it means it will get ready only when extraConditionSignal
        is 1 for slave it means it will not get valid only
        when extraConditionSignal is 1 but all interfaces have to wait
        on each other
    :ivar skipWhen: dict interface : skipSignal
        where if skipSignal is high interface is disconnected from stream
        sync node and others does not have to wait on it
        (master does not need to have valid and slave ready)
    :attention: skipWhen has higher priority
    """

    def __init__(self, masters=None, slaves=None,
                 extraConds=None, skipWhen=None):
        if masters is None:
            masters = []
        if slaves is None:
            slaves = []
        if extraConds is None:
            extraConds = {}
        if skipWhen is None:
            skipWhen = {}

        self.masters = masters
        self.slaves = slaves
        self.extraConds = extraConds
        self.skipWhen = skipWhen

    def sync(self, enSig=None):
        """
        Create synchronization logic between streams
        (generate valid/ready synchronization logic for interfaces)

        :param enSig: optional signal to enable this node
        :return: list of assignements which are responsible for synchronization of streams
        """
        masters = self.masters
        slaves = self.slaves

        if not masters and not slaves:
            # node is empty
            assert not self.extraConds
            assert not self.skipWhen
            return []

        # check if there is not not any mess in extraConds/skipWhen
        for i in self.extraConds.keys():
            assert i in masters or i in slaves, i

        for i in self.skipWhen.keys():
            assert i in masters or i in slaves, i

        # this expression container is there to allow usage of this function
        # in usual hdl containers like If, Switch etc...
        expression = []
        for m in masters:
            r = self.ackForMaster(m)
            if enSig is not None:
                r = r & enSig

            if isinstance(m, ExclusiveStreamGroups):
                a = m.sync(r)
            else:
                a = [_getRd(m)(r), ]

            expression.extend(a)

        for s in slaves:
            v = self.ackForSlave(s)

            if enSig is not None:
                v = v & enSig

            if isinstance(s, ExclusiveStreamGroups):
                a = s.sync(v)
            else:
                a = [_getVld(s)(v), ]

            expression.extend(a)

        return expression

    def ack(self):
        """
        :return: expression which's value is high when transaction can be made over interfaces
        """
        # every interface has to have skip flag or it has to be ready/valid
        # and extraCond has to be True if present
        acks = []
        for m in self.masters:
            extra, skip = self.getExtraAndSkip(m)
            if isinstance(m, ExclusiveStreamGroups):
                a = m.ack()
            else:
                a = _getVld(m)

            if extra:
                a = And(a, *extra)

            if skip is not None:
                a = Or(a, skip)

            acks.append(a)

        for s in self.slaves:
            extra, skip = self.getExtraAndSkip(s)
            if isinstance(s, ExclusiveStreamGroups):
                a = s.ack()
            else:
                a = _getRd(s)

            if extra:
                a = And(a, *extra)

            if skip is not None:
                a = Or(a, skip)

            acks.append(a)

        if not acks:
            return True

        return And(*acks)

    def getExtraAndSkip(self, intf):
        """
        :return: optional extraCond and skip flags for interface
        """
        try:
            extra = [self.extraConds[intf], ]
        except KeyError:
            extra = []

        try:
            skip = self.skipWhen[intf]
        except KeyError:
            skip = None

        return extra, skip

    def vld(self, intf):
        """
        :return: valid signal of master interface for synchronization of othres
        """
        try:
            s = self.skipWhen[intf]
            assert s is not None
        except KeyError:
            s = None

        if isinstance(intf, ExclusiveStreamGroups):
            v = intf.ack()
        else:
            v = _getVld(intf)

        if s is None:
            return v
        else:
            return v | s

    def rd(self, intf):
        """
        :return: ready signal of slave interface for synchronization of othres
        """
        try:
            s = self.skipWhen[intf]
            assert s is not None
        except KeyError:
            s = None

        if isinstance(intf, ExclusiveStreamGroups):
            r = intf.ack()
        else:
            r = _getRd(intf)

        if s is None:
            return r
        else:
            return r | s

    def ackForMaster(self, master):
        """
        :return: driver of ready signal for master
        """
        otherMasters = where(self.masters, lambda x: x is not master)
        extra, skip = self.getExtraAndSkip(master)

        conds = [*map(self.vld, otherMasters),
                 *map(self.rd, self.slaves),
                 *extra]
        if conds:
            r = And(*conds)
        else:
            r = hBit(1)

        if skip is not None:
            r = r & ~skip

        return r

    def ackForSlave(self, slave):
        """
        :return: driver of valid signal for slave
        """
        otherSlaves = where(self.slaves, lambda x: x is not slave)
        extra, skip = self.getExtraAndSkip(slave)

        conds = [*map(self.vld, self.masters),
                 *map(self.rd, otherSlaves),
                 *extra]
        if conds:
            v = And(*conds)
        else:
            v = hBit(1)

        if skip is not None:
            v = v & ~skip

        return v

Query: list the first 100 Fibonacci Numbers

************************** NEXT RESULT **************************************
#
# Copyright 2013 Intel Corporation
# All Rights Reserved.
#
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.

from __future__ import print_function

from oslo_serialization import jsonutils
import yaml

from tackerclient.common import exceptions
from tackerclient.i18n import _
from tackerclient.tacker import v1_0 as tackerV10


_VNFD = "vnfd"


class ListVNFD(tackerV10.ListCommand):
    """List VNFD that belong to a given tenant."""

    resource = _VNFD
    list_columns = ['id', 'name', 'template_source', 'description']

    def get_parser(self, prog_name):
        parser = super(ListVNFD, self).get_parser(prog_name)
        parser.add_argument(
            '--template-source',
            help=_("List VNFD with specified template source. Available \
                   options are 'onboarded' (default), 'inline' or 'all'"),
            action='store',
            default='onboarded')
        return parser

    def args2search_opts(self, parsed_args):
        search_opts = super(ListVNFD, self).args2search_opts(parsed_args)
        template_source = parsed_args.template_source
        if parsed_args.template_source:
            search_opts.update({'template_source': template_source})
        return search_opts


class ShowVNFD(tackerV10.ShowCommand):
    """Show information of a given VNFD."""

    resource = _VNFD


class CreateVNFD(tackerV10.CreateCommand):
    """Create a VNFD."""

    resource = _VNFD
    remove_output_fields = ["attributes"]

    def add_known_arguments(self, parser):
        parser.add_argument('--vnfd-file', help=_('Specify VNFD file'))
        parser.add_argument(
            'name', metavar='NAME',
            help=_('Set a name for the VNFD'))
        parser.add_argument(
            '--description',
            help=_('Set a description for the VNFD'))

    def args2body(self, parsed_args):
        body = {self.resource: {}}
        vnfd = None
        if not parsed_args.vnfd_file:
            raise exceptions.InvalidInput("Invalid input for vnfd file")
        with open(parsed_args.vnfd_file) as f:
            vnfd = f.read()
            try:
                vnfd = yaml.load(vnfd, Loader=yaml.SafeLoader)
            except yaml.YAMLError as e:
                raise exceptions.InvalidInput(e)
            if not vnfd:
                raise exceptions.InvalidInput("vnfd file is empty")
            body[self.resource]['attributes'] = {'vnfd': vnfd}
        tackerV10.update_dict(parsed_args, body[self.resource],
                              ['tenant_id', 'name', 'description'])
        return body


class DeleteVNFD(tackerV10.DeleteCommand):
    """Delete given VNFD(s)."""
    resource = _VNFD


class ShowTemplateVNFD(tackerV10.ShowCommand):
    """Show template of a given VNFD."""

    resource = _VNFD

    def run(self, parsed_args):
        self.log.debug('run(%s)', parsed_args)
        template = None
        data = self.get_data(parsed_args)
        try:
            attributes_index = data[0].index('attributes')
            attributes_json = data[1][attributes_index]
            template = jsonutils.loads(attributes_json).get('vnfd', None)
        except (IndexError, TypeError, ValueError) as e:
            self.log.debug('Data handling error: %s', str(e))
        print(template or _('Unable to display VNFD template!'))

